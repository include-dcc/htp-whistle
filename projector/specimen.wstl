// Specimen

// The Subject ID is currently baked into the sample_id but 
// we'll pass it along on the off chance that we decide to 
// change that rule and will only require a single change 
// to handle it  
def SpecimenIdentifier(study, subject_id, sample_id) {
    $this: $StrCat(sample_id);
}


def ConcentrationQuantityExtension(study, aliquot) {
    if (aliquot.concentration ~= "NA") {
        url: "https://ncpi-fhir.github.io/ncpi-fhir-ig/StructureDefinition/concentration-quantity";
        valueQuantity.unit: "Cells/mL";
        valueQuantity.system: "http://ucum.org";
        valueQuantity.value: $ParseFloat(aliquot.concentration);
        valueQuantity.code: "Cells/mL";
    }
}

def ProcessAliquot(study, subject_id, aliquot) {
    identifier[]: Key_Identifier(study,"biospecimen/container/id", aliquot.barcode );
    identifier[0].use: "official";
    specimenQuantity.value: $ParseFloat(aliquot.vial_volume);
    specimenQuantity.unit: "ml";
    specimenQuantity.code: "ml";
    specimenQuantity.system: "http://ucum.org";
    description: aliquot.biospecimen_storage;
    extension[0]: ConcentrationQuantityExtension(study, aliquot);

    if (aliquot.preservation_method? and aliquot.preservation_method ~= "NA") {
        additiveReference: Reference_Key_Identifier(study, "Substance", SubstanceIdentifier(study, aliquot.preservation_method))
    }
}

def ProcessSpecimen(study, specimen, all_aliquots, participants) {
    // We may not get subject id or it's name will change. This is based on 
    // RJC example but the final dataset may look very different.
    //var subject_id: $SubStr(specimen.lab_id, 0, 7);
    var subject_id: specimen.subject_id;

    var matching_subject: participants[where $.participantid=subject_id];
    if ($ListLen(matching_subject) > 0) {
        var aliquots: all_aliquots[where $.sample_id=specimen.sample_id];
        
        meta.tag[]: StudyMeta(study);
        
        // add labID to identifier as separate entry???
        identifier[0]: Key_Identifier(study, "Specimen", SpecimenIdentifier(study, subject_id, specimen.sample_id));
        identifier[0].use: "official";
        
        if (specimen.parent_sample_id?) {
            parent[] (if specimen.parent_sample_id ~= specimen.sample_id): Reference_Key_Identifier(study, "Specimen", SpecimenIdentifier(study, subject_id, specimen.parent_sample_id));
        }

        // Do we actually want to consider the volume inside "vial volume"
        if (specimen.in_out = "In") {
            status: "available";
        } else {
            status: "unavailable";
        }

        var substance_code: HarmonizeMapped(specimen.preservation_method, "SpecimenAdditive");
        if (substance_code?) {
            processing[0].additive[0]: Reference_Key_Identifier(study, "Substance", SubstanceIdentifier(study, specimen.preservation_method));
        }

        processing[0].description: specimen.laboratory_procedure;
        condition[0].coding[]: HarmonizeMapped(specimen.preservation_method, "SpecimenCondition");
        condition[0].text: specimen.preservation_method;

        type.coding[]: HarmonizeMapped(specimen.sample_type, "SpecimenType");
        type.text: specimen.sample_type
        var subref: Reference_Key_Identifier(study, "Patient", subject_id);

        // No consistency...ever
        collection._collectedDateTime.extension[0] (if specimen.age_at_collection ~= "NA" and specimen.age_at_collection ~= "#N/A"): AgeAtExtension(study, subref, specimen.age_at_collection, "days");
        container[]: ProcessAliquot(study, subject_id, aliquots[]);

        subject: Reference_Key_Identifier(study, "Patient", subject_id);
        resourceType: "Specimen";    
    }
}

def ProcessSpecimenData(study, all_specimen, all_aliquots, participants) {
    out specimen: ProcessSpecimen(study, all_specimen[], all_aliquots[*], participants[*]);
}